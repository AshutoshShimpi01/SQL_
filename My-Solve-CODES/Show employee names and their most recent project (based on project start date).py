-- Show employee names and their most recent project (based on project start date).

SELECT E.name, P.project_name
FROM employees E
JOIN employee_project_assignments EP ON E.emp_id = EP.emp_id
JOIN projects P ON EP.project_id = P.project_id
WHERE P.start_date = (
        SELECT MAX(P2.start_date) 
        FROM employee_project_assignments EP2
        JOIN projects P2 ON EP2.project_id = P2.project_id
        WHERE EP2.emp_id = E.emp_id 
    );

---------
Explination
----------



You're asking for an explanation of the last **correct** SQL query provided for the problem: "Show employee names and their most recent project (based on project start date)," using the **Subquery/Correlated Subquery** approach.

Here is the explanation of the correct logic:

## The Query: Subquery Approach

```sql
SELECT
    E.name,
    P.project_name
FROM
    employees E
JOIN
    employee_project_assignments EP ON E.emp_id = EP.emp_id
JOIN
    projects P ON EP.project_id = P.project_id
WHERE
    P.start_date = (
        SELECT 
            MAX(P2.start_date) 
        FROM 
            employee_project_assignments EP2
        JOIN 
            projects P2 ON EP2.project_id = P2.project_id
        WHERE 
            EP2.emp_id = E.emp_id 
    );
```

-----

## Explanation of the Logic

The goal is to find the single project (`P.project_name`) that corresponds to the **latest start date** (`MAX(P.start_date)`) for each employee (`E.name`). Standard grouping fails here because you can't mix `MAX()` with non-grouped columns that vary (like `project_name`).

This query solves the problem by using a **Correlated Subquery** in the `WHERE` clause.

### 1\. The Outer Query (The List)

```sql
SELECT
    E.name,
    P.project_name
FROM
    employees E
JOIN
    employee_project_assignments EP ON E.emp_id = EP.emp_id
JOIN
    projects P ON EP.project_id = P.project_id
```

This is the main query. It creates a complete list of **every employee and every project they ever worked on** (including the project's start date). This full list is what we need to filter.

-----

### 2\. The Inner Query (The Filter/Condition)

```sql
WHERE P.start_date = (
    SELECT MAX(P2.start_date) 
    FROM employee_project_assignments EP2
    JOIN projects P2 ON EP2.project_id = P2.project_id
    WHERE EP2.emp_id = E.emp_id -- THE CORRELATION POINT
);
```

This is the crucial part that performs the logic:

  * **Execution Per Row:** The inner `SELECT MAX(P2.start_date)` query runs **once for every single row** generated by the outer query.
  * **Correlation:** The clause `WHERE EP2.emp_id = E.emp_id` is the **correlation**. It links the inner query (aliased as `E2`/`P2`) back to the specific employee (`E`) currently being processed by the outer query.
  * **The Result:** The inner query finds and returns the **single latest `start_date`** for *that employee*.
  * **The Filter:** The outer `WHERE` clause then keeps only the rows where the project's `start_date` (`P.start_date`) **equals** that maximum date returned by the subquery.

In essence, the query filters the complete history of an employee's projects, leaving only the one (or ones, if dates are tied) that matches their latest project start date.
